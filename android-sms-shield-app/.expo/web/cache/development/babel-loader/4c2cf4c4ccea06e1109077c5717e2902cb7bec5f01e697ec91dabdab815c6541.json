{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport findNodeHandle from '../../findNodeHandle';\nimport PointerEventManager from './PointerEventManager';\nimport { State } from '../../State';\nimport { isPointerInBounds } from '../utils';\nimport { MouseButton } from '../../handlers/gestureHandlerCommon';\nimport KeyboardEventManager from './KeyboardEventManager';\nimport WheelEventManager from './WheelEventManager';\nexport class GestureHandlerWebDelegate {\n  constructor() {\n    _defineProperty(this, \"isInitialized\", false);\n    _defineProperty(this, \"_view\", void 0);\n    _defineProperty(this, \"gestureHandler\", void 0);\n    _defineProperty(this, \"eventManagers\", []);\n    _defineProperty(this, \"defaultViewStyles\", {\n      userSelect: '',\n      touchAction: ''\n    });\n  }\n  init(viewRef, handler) {\n    if (!viewRef) {\n      throw new Error(`Cannot find HTML Element for handler ${handler.handlerTag}`);\n    }\n    this.isInitialized = true;\n    this.gestureHandler = handler;\n    this.view = findNodeHandle(viewRef);\n    this.defaultViewStyles = {\n      userSelect: this.view.style.userSelect,\n      touchAction: this.view.style.touchAction\n    };\n    const config = handler.config;\n    this.setUserSelect(config.enabled);\n    this.setTouchAction(config.enabled);\n    this.setContextMenu(config.enabled);\n    this.eventManagers.push(new PointerEventManager(this.view));\n    this.eventManagers.push(new KeyboardEventManager(this.view));\n    this.eventManagers.push(new WheelEventManager(this.view));\n    this.eventManagers.forEach(manager => this.gestureHandler.attachEventManager(manager));\n  }\n  isPointerInBounds({\n    x,\n    y\n  }) {\n    return isPointerInBounds(this.view, {\n      x,\n      y\n    });\n  }\n  measureView() {\n    const rect = this.view.getBoundingClientRect();\n    return {\n      pageX: rect.left,\n      pageY: rect.top,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n  reset() {\n    this.eventManagers.forEach(manager => manager.resetManager());\n  }\n  tryResetCursor() {\n    const config = this.gestureHandler.config;\n    if (config.activeCursor && config.activeCursor !== 'auto' && this.gestureHandler.state === State.ACTIVE) {\n      this.view.style.cursor = 'auto';\n    }\n  }\n  shouldDisableContextMenu(config) {\n    return config.enableContextMenu === undefined && this.gestureHandler.isButtonInConfig(MouseButton.RIGHT) || config.enableContextMenu === false;\n  }\n  addContextMenuListeners(config) {\n    if (this.shouldDisableContextMenu(config)) {\n      this.view.addEventListener('contextmenu', this.disableContextMenu);\n    } else if (config.enableContextMenu) {\n      this.view.addEventListener('contextmenu', this.enableContextMenu);\n    }\n  }\n  removeContextMenuListeners(config) {\n    if (this.shouldDisableContextMenu(config)) {\n      this.view.removeEventListener('contextmenu', this.disableContextMenu);\n    } else if (config.enableContextMenu) {\n      this.view.removeEventListener('contextmenu', this.enableContextMenu);\n    }\n  }\n  disableContextMenu(e) {\n    e.preventDefault();\n  }\n  enableContextMenu(e) {\n    e.stopPropagation();\n  }\n  setUserSelect(isHandlerEnabled) {\n    const {\n      userSelect\n    } = this.gestureHandler.config;\n    this.view.style['userSelect'] = isHandlerEnabled ? userSelect !== null && userSelect !== void 0 ? userSelect : 'none' : this.defaultViewStyles.userSelect;\n    this.view.style['webkitUserSelect'] = isHandlerEnabled ? userSelect !== null && userSelect !== void 0 ? userSelect : 'none' : this.defaultViewStyles.userSelect;\n  }\n  setTouchAction(isHandlerEnabled) {\n    const {\n      touchAction\n    } = this.gestureHandler.config;\n    this.view.style['touchAction'] = isHandlerEnabled ? touchAction !== null && touchAction !== void 0 ? touchAction : 'none' : this.defaultViewStyles.touchAction;\n    this.view.style['WebkitTouchCallout'] = isHandlerEnabled ? touchAction !== null && touchAction !== void 0 ? touchAction : 'none' : this.defaultViewStyles.touchAction;\n  }\n  setContextMenu(isHandlerEnabled) {\n    const config = this.gestureHandler.config;\n    if (isHandlerEnabled) {\n      this.addContextMenuListeners(config);\n    } else {\n      this.removeContextMenuListeners(config);\n    }\n  }\n  onEnabledChange(enabled) {\n    if (!this.isInitialized) {\n      return;\n    }\n    this.setUserSelect(enabled);\n    this.setTouchAction(enabled);\n    this.setContextMenu(enabled);\n    if (enabled) {\n      this.eventManagers.forEach(manager => {\n        manager.registerListeners();\n      });\n    } else {\n      this.eventManagers.forEach(manager => {\n        manager.unregisterListeners();\n      });\n    }\n  }\n  onBegin() {}\n  onActivate() {\n    const config = this.gestureHandler.config;\n    if ((!this.view.style.cursor || this.view.style.cursor === 'auto') && config.activeCursor) {\n      this.view.style.cursor = config.activeCursor;\n    }\n  }\n  onEnd() {\n    this.tryResetCursor();\n  }\n  onCancel() {\n    this.tryResetCursor();\n  }\n  onFail() {\n    this.tryResetCursor();\n  }\n  destroy(config) {\n    this.removeContextMenuListeners(config);\n    this.eventManagers.forEach(manager => {\n      manager.unregisterListeners();\n    });\n  }\n  get view() {\n    return this._view;\n  }\n  set view(value) {\n    this._view = value;\n  }\n}","map":{"version":3,"names":["findNodeHandle","PointerEventManager","State","isPointerInBounds","MouseButton","KeyboardEventManager","WheelEventManager","GestureHandlerWebDelegate","constructor","_defineProperty","userSelect","touchAction","init","viewRef","handler","Error","handlerTag","isInitialized","gestureHandler","view","defaultViewStyles","style","config","setUserSelect","enabled","setTouchAction","setContextMenu","eventManagers","push","forEach","manager","attachEventManager","x","y","measureView","rect","getBoundingClientRect","pageX","left","pageY","top","width","height","reset","resetManager","tryResetCursor","activeCursor","state","ACTIVE","cursor","shouldDisableContextMenu","enableContextMenu","undefined","isButtonInConfig","RIGHT","addContextMenuListeners","addEventListener","disableContextMenu","removeContextMenuListeners","removeEventListener","e","preventDefault","stopPropagation","isHandlerEnabled","onEnabledChange","registerListeners","unregisterListeners","onBegin","onActivate","onEnd","onCancel","onFail","destroy","_view","value"],"sources":["C:\\Users\\Ntino\\Desktop\\End of year project\\N-pro\\android-sms-shield-app\\node_modules\\react-native-gesture-handler\\lib\\module\\web\\tools\\GestureHandlerWebDelegate.ts"],"sourcesContent":["import findNodeHandle from '../../findNodeHandle';\nimport type IGestureHandler from '../handlers/IGestureHandler';\nimport {\n  GestureHandlerDelegate,\n  MeasureResult,\n} from './GestureHandlerDelegate';\nimport PointerEventManager from './PointerEventManager';\nimport { State } from '../../State';\nimport { isPointerInBounds } from '../utils';\nimport EventManager from './EventManager';\nimport { Config } from '../interfaces';\nimport { MouseButton } from '../../handlers/gestureHandlerCommon';\nimport KeyboardEventManager from './KeyboardEventManager';\nimport WheelEventManager from './WheelEventManager';\n\ninterface DefaultViewStyles {\n  userSelect: string;\n  touchAction: string;\n}\n\nexport class GestureHandlerWebDelegate\n  implements GestureHandlerDelegate<HTMLElement, IGestureHandler>\n{\n  private isInitialized = false;\n  private _view!: HTMLElement;\n\n  private gestureHandler!: IGestureHandler;\n  private eventManagers: EventManager<unknown>[] = [];\n  private defaultViewStyles: DefaultViewStyles = {\n    userSelect: '',\n    touchAction: '',\n  };\n\n  init(viewRef: number, handler: IGestureHandler): void {\n    if (!viewRef) {\n      throw new Error(\n        `Cannot find HTML Element for handler ${handler.handlerTag}`\n      );\n    }\n\n    this.isInitialized = true;\n\n    this.gestureHandler = handler;\n    this.view = findNodeHandle(viewRef) as unknown as HTMLElement;\n\n    this.defaultViewStyles = {\n      userSelect: this.view.style.userSelect,\n      touchAction: this.view.style.touchAction,\n    };\n\n    const config = handler.config;\n\n    this.setUserSelect(config.enabled);\n    this.setTouchAction(config.enabled);\n    this.setContextMenu(config.enabled);\n\n    this.eventManagers.push(new PointerEventManager(this.view));\n    this.eventManagers.push(new KeyboardEventManager(this.view));\n    this.eventManagers.push(new WheelEventManager(this.view));\n\n    this.eventManagers.forEach((manager) =>\n      this.gestureHandler.attachEventManager(manager)\n    );\n  }\n\n  isPointerInBounds({ x, y }: { x: number; y: number }): boolean {\n    return isPointerInBounds(this.view, { x, y });\n  }\n\n  measureView(): MeasureResult {\n    const rect = this.view.getBoundingClientRect();\n\n    return {\n      pageX: rect.left,\n      pageY: rect.top,\n      width: rect.width,\n      height: rect.height,\n    };\n  }\n\n  reset(): void {\n    this.eventManagers.forEach((manager: EventManager<unknown>) =>\n      manager.resetManager()\n    );\n  }\n\n  tryResetCursor() {\n    const config = this.gestureHandler.config;\n\n    if (\n      config.activeCursor &&\n      config.activeCursor !== 'auto' &&\n      this.gestureHandler.state === State.ACTIVE\n    ) {\n      this.view.style.cursor = 'auto';\n    }\n  }\n\n  private shouldDisableContextMenu(config: Config) {\n    return (\n      (config.enableContextMenu === undefined &&\n        this.gestureHandler.isButtonInConfig(MouseButton.RIGHT)) ||\n      config.enableContextMenu === false\n    );\n  }\n\n  private addContextMenuListeners(config: Config): void {\n    if (this.shouldDisableContextMenu(config)) {\n      this.view.addEventListener('contextmenu', this.disableContextMenu);\n    } else if (config.enableContextMenu) {\n      this.view.addEventListener('contextmenu', this.enableContextMenu);\n    }\n  }\n\n  private removeContextMenuListeners(config: Config): void {\n    if (this.shouldDisableContextMenu(config)) {\n      this.view.removeEventListener('contextmenu', this.disableContextMenu);\n    } else if (config.enableContextMenu) {\n      this.view.removeEventListener('contextmenu', this.enableContextMenu);\n    }\n  }\n\n  private disableContextMenu(this: void, e: MouseEvent): void {\n    e.preventDefault();\n  }\n\n  private enableContextMenu(this: void, e: MouseEvent): void {\n    e.stopPropagation();\n  }\n\n  private setUserSelect(isHandlerEnabled: boolean) {\n    const { userSelect } = this.gestureHandler.config;\n\n    this.view.style['userSelect'] = isHandlerEnabled\n      ? (userSelect ?? 'none')\n      : this.defaultViewStyles.userSelect;\n\n    this.view.style['webkitUserSelect'] = isHandlerEnabled\n      ? (userSelect ?? 'none')\n      : this.defaultViewStyles.userSelect;\n  }\n\n  private setTouchAction(isHandlerEnabled: boolean) {\n    const { touchAction } = this.gestureHandler.config;\n\n    this.view.style['touchAction'] = isHandlerEnabled\n      ? (touchAction ?? 'none')\n      : this.defaultViewStyles.touchAction;\n\n    // @ts-ignore This one disables default events on Safari\n    this.view.style['WebkitTouchCallout'] = isHandlerEnabled\n      ? (touchAction ?? 'none')\n      : this.defaultViewStyles.touchAction;\n  }\n\n  private setContextMenu(isHandlerEnabled: boolean) {\n    const config = this.gestureHandler.config;\n\n    if (isHandlerEnabled) {\n      this.addContextMenuListeners(config);\n    } else {\n      this.removeContextMenuListeners(config);\n    }\n  }\n\n  onEnabledChange(enabled: boolean): void {\n    if (!this.isInitialized) {\n      return;\n    }\n\n    this.setUserSelect(enabled);\n    this.setTouchAction(enabled);\n    this.setContextMenu(enabled);\n\n    if (enabled) {\n      this.eventManagers.forEach((manager) => {\n        // It may look like managers will be registered twice when handler is mounted for the first time.\n        // However, `init` method is called AFTER `updateGestureConfig` - it means that delegate has not\n        // been initialized yet, so this code won't be executed.\n        //\n        // Also, because we use defined functions, not lambdas, they will not be registered multiple times.\n        manager.registerListeners();\n      });\n    } else {\n      this.eventManagers.forEach((manager) => {\n        manager.unregisterListeners();\n      });\n    }\n  }\n\n  onBegin(): void {\n    // no-op for now\n  }\n\n  onActivate(): void {\n    const config = this.gestureHandler.config;\n\n    if (\n      (!this.view.style.cursor || this.view.style.cursor === 'auto') &&\n      config.activeCursor\n    ) {\n      this.view.style.cursor = config.activeCursor;\n    }\n  }\n\n  onEnd(): void {\n    this.tryResetCursor();\n  }\n\n  onCancel(): void {\n    this.tryResetCursor();\n  }\n\n  onFail(): void {\n    this.tryResetCursor();\n  }\n\n  public destroy(config: Config): void {\n    this.removeContextMenuListeners(config);\n\n    this.eventManagers.forEach((manager) => {\n      manager.unregisterListeners();\n    });\n  }\n\n  public get view() {\n    return this._view;\n  }\n  public set view(value: HTMLElement) {\n    this._view = value;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}