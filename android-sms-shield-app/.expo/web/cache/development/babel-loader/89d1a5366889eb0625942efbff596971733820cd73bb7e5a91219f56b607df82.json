{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { DEFAULT_TOUCH_SLOP } from '../constants';\nimport { EventTypes } from '../interfaces';\nexport default class ScaleGestureDetector {\n  constructor(callbacks) {\n    _defineProperty(this, \"onScaleBegin\", void 0);\n    _defineProperty(this, \"onScale\", void 0);\n    _defineProperty(this, \"onScaleEnd\", void 0);\n    _defineProperty(this, \"_focusX\", void 0);\n    _defineProperty(this, \"_focusY\", void 0);\n    _defineProperty(this, \"_currentSpan\", void 0);\n    _defineProperty(this, \"prevSpan\", void 0);\n    _defineProperty(this, \"initialSpan\", void 0);\n    _defineProperty(this, \"currentTime\", void 0);\n    _defineProperty(this, \"prevTime\", void 0);\n    _defineProperty(this, \"inProgress\", false);\n    _defineProperty(this, \"spanSlop\", void 0);\n    _defineProperty(this, \"minSpan\", void 0);\n    this.onScaleBegin = callbacks.onScaleBegin;\n    this.onScale = callbacks.onScale;\n    this.onScaleEnd = callbacks.onScaleEnd;\n    this.spanSlop = DEFAULT_TOUCH_SLOP * 2;\n    this.minSpan = 0;\n  }\n  onTouchEvent(event, tracker) {\n    this.currentTime = event.time;\n    const action = event.eventType;\n    const numOfPointers = tracker.trackedPointersCount;\n    const streamComplete = action === EventTypes.UP || action === EventTypes.ADDITIONAL_POINTER_UP || action === EventTypes.CANCEL;\n    if (action === EventTypes.DOWN || streamComplete) {\n      if (this.inProgress) {\n        this.onScaleEnd(this);\n        this.inProgress = false;\n        this.initialSpan = 0;\n      }\n      if (streamComplete) {\n        return true;\n      }\n    }\n    const configChanged = action === EventTypes.DOWN || action === EventTypes.ADDITIONAL_POINTER_UP || action === EventTypes.ADDITIONAL_POINTER_DOWN;\n    const pointerUp = action === EventTypes.ADDITIONAL_POINTER_UP;\n    const ignoredPointer = pointerUp ? event.pointerId : undefined;\n    const div = pointerUp ? numOfPointers - 1 : numOfPointers;\n    const coordsSum = tracker.getAbsoluteCoordsSum();\n    const focusX = coordsSum.x / div;\n    const focusY = coordsSum.y / div;\n    let devSumX = 0;\n    let devSumY = 0;\n    tracker.trackedPointers.forEach((value, key) => {\n      if (key === ignoredPointer) {\n        return;\n      }\n      devSumX += Math.abs(value.abosoluteCoords.x - focusX);\n      devSumY += Math.abs(value.abosoluteCoords.y - focusY);\n    });\n    const devX = devSumX / div;\n    const devY = devSumY / div;\n    const spanX = devX * 2;\n    const spanY = devY * 2;\n    const span = Math.hypot(spanX, spanY);\n    const wasInProgress = this.inProgress;\n    this._focusX = focusX;\n    this._focusY = focusY;\n    if (this.inProgress && (span < this.minSpan || configChanged)) {\n      this.onScaleEnd(this);\n      this.inProgress = false;\n      this.initialSpan = span;\n    }\n    if (configChanged) {\n      this.initialSpan = this.prevSpan = this._currentSpan = span;\n    }\n    if (!this.inProgress && span >= this.minSpan && (wasInProgress || Math.abs(span - this.initialSpan) > this.spanSlop)) {\n      this.prevSpan = this._currentSpan = span;\n      this.prevTime = this.currentTime;\n      this.inProgress = this.onScaleBegin(this);\n    }\n    if (action !== EventTypes.MOVE) {\n      return true;\n    }\n    this._currentSpan = span;\n    if (this.inProgress && !this.onScale(this)) {\n      return true;\n    }\n    this.prevSpan = this.currentSpan;\n    this.prevTime = this.currentTime;\n    return true;\n  }\n  calculateScaleFactor(numOfPointers) {\n    if (numOfPointers < 2) {\n      return 1;\n    }\n    return this.prevSpan > 0 ? this.currentSpan / this.prevSpan : 1;\n  }\n  get currentSpan() {\n    return this._currentSpan;\n  }\n  get focusX() {\n    return this._focusX;\n  }\n  get focusY() {\n    return this._focusY;\n  }\n  get timeDelta() {\n    return this.currentTime - this.prevTime;\n  }\n}","map":{"version":3,"names":["DEFAULT_TOUCH_SLOP","EventTypes","ScaleGestureDetector","constructor","callbacks","_defineProperty","onScaleBegin","onScale","onScaleEnd","spanSlop","minSpan","onTouchEvent","event","tracker","currentTime","time","action","eventType","numOfPointers","trackedPointersCount","streamComplete","UP","ADDITIONAL_POINTER_UP","CANCEL","DOWN","inProgress","initialSpan","configChanged","ADDITIONAL_POINTER_DOWN","pointerUp","ignoredPointer","pointerId","undefined","div","coordsSum","getAbsoluteCoordsSum","focusX","x","focusY","y","devSumX","devSumY","trackedPointers","forEach","value","key","Math","abs","abosoluteCoords","devX","devY","spanX","spanY","span","hypot","wasInProgress","_focusX","_focusY","prevSpan","_currentSpan","prevTime","MOVE","currentSpan","calculateScaleFactor","timeDelta"],"sources":["C:\\Users\\Ntino\\Desktop\\End of year project\\N-pro\\android-sms-shield-app\\node_modules\\react-native-gesture-handler\\lib\\module\\web\\detectors\\ScaleGestureDetector.ts"],"sourcesContent":["import { DEFAULT_TOUCH_SLOP } from '../constants';\nimport { AdaptedEvent, EventTypes } from '../interfaces';\n\nimport PointerTracker from '../tools/PointerTracker';\n\nexport interface ScaleGestureListener {\n  onScaleBegin: (detector: ScaleGestureDetector) => boolean;\n  onScale: (detector: ScaleGestureDetector) => boolean;\n  onScaleEnd: (detector: ScaleGestureDetector) => void;\n}\n\nexport default class ScaleGestureDetector implements ScaleGestureListener {\n  public onScaleBegin: (detector: ScaleGestureDetector) => boolean;\n  public onScale: (detector: ScaleGestureDetector) => boolean;\n  public onScaleEnd: (detector: ScaleGestureDetector) => void;\n\n  private _focusX!: number;\n  private _focusY!: number;\n\n  private _currentSpan!: number;\n  private prevSpan!: number;\n  private initialSpan!: number;\n\n  private currentTime!: number;\n  private prevTime!: number;\n\n  private inProgress = false;\n\n  private spanSlop: number;\n  private minSpan: number;\n\n  constructor(callbacks: ScaleGestureListener) {\n    this.onScaleBegin = callbacks.onScaleBegin;\n    this.onScale = callbacks.onScale;\n    this.onScaleEnd = callbacks.onScaleEnd;\n\n    this.spanSlop = DEFAULT_TOUCH_SLOP * 2;\n    this.minSpan = 0;\n  }\n\n  public onTouchEvent(event: AdaptedEvent, tracker: PointerTracker): boolean {\n    this.currentTime = event.time;\n\n    const action: EventTypes = event.eventType;\n    const numOfPointers = tracker.trackedPointersCount;\n\n    const streamComplete: boolean =\n      action === EventTypes.UP ||\n      action === EventTypes.ADDITIONAL_POINTER_UP ||\n      action === EventTypes.CANCEL;\n\n    if (action === EventTypes.DOWN || streamComplete) {\n      if (this.inProgress) {\n        this.onScaleEnd(this);\n        this.inProgress = false;\n        this.initialSpan = 0;\n      }\n\n      if (streamComplete) {\n        return true;\n      }\n    }\n\n    const configChanged: boolean =\n      action === EventTypes.DOWN ||\n      action === EventTypes.ADDITIONAL_POINTER_UP ||\n      action === EventTypes.ADDITIONAL_POINTER_DOWN;\n\n    const pointerUp = action === EventTypes.ADDITIONAL_POINTER_UP;\n\n    const ignoredPointer: number | undefined = pointerUp\n      ? event.pointerId\n      : undefined;\n\n    // Determine focal point\n\n    const div: number = pointerUp ? numOfPointers - 1 : numOfPointers;\n\n    const coordsSum = tracker.getAbsoluteCoordsSum();\n\n    const focusX = coordsSum.x / div;\n    const focusY = coordsSum.y / div;\n\n    // Determine average deviation from focal point\n\n    let devSumX = 0;\n    let devSumY = 0;\n\n    tracker.trackedPointers.forEach((value, key) => {\n      if (key === ignoredPointer) {\n        return;\n      }\n\n      devSumX += Math.abs(value.abosoluteCoords.x - focusX);\n      devSumY += Math.abs(value.abosoluteCoords.y - focusY);\n    });\n\n    const devX: number = devSumX / div;\n    const devY: number = devSumY / div;\n\n    const spanX: number = devX * 2;\n    const spanY: number = devY * 2;\n\n    const span = Math.hypot(spanX, spanY);\n\n    // Begin/end events\n    const wasInProgress: boolean = this.inProgress;\n    this._focusX = focusX;\n    this._focusY = focusY;\n\n    if (this.inProgress && (span < this.minSpan || configChanged)) {\n      this.onScaleEnd(this);\n      this.inProgress = false;\n      this.initialSpan = span;\n    }\n\n    if (configChanged) {\n      this.initialSpan = this.prevSpan = this._currentSpan = span;\n    }\n\n    if (\n      !this.inProgress &&\n      span >= this.minSpan &&\n      (wasInProgress || Math.abs(span - this.initialSpan) > this.spanSlop)\n    ) {\n      this.prevSpan = this._currentSpan = span;\n      this.prevTime = this.currentTime;\n      this.inProgress = this.onScaleBegin(this);\n    }\n\n    // Handle motion\n    if (action !== EventTypes.MOVE) {\n      return true;\n    }\n\n    this._currentSpan = span;\n\n    if (this.inProgress && !this.onScale(this)) {\n      return true;\n    }\n\n    this.prevSpan = this.currentSpan;\n    this.prevTime = this.currentTime;\n\n    return true;\n  }\n\n  public calculateScaleFactor(numOfPointers: number): number {\n    if (numOfPointers < 2) {\n      return 1;\n    }\n\n    return this.prevSpan > 0 ? this.currentSpan / this.prevSpan : 1;\n  }\n\n  public get currentSpan() {\n    return this._currentSpan;\n  }\n\n  public get focusX() {\n    return this._focusX;\n  }\n\n  public get focusY() {\n    return this._focusY;\n  }\n\n  public get timeDelta() {\n    return this.currentTime - this.prevTime;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}